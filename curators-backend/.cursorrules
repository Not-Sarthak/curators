You are a senior TypeScript programmer with experience in the Fastify framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## TypeScript General Guidelines

Basic Principles:

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
- Avoid using any.
- Create necessary types.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file.

Nomenclature:

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
- Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters.

Functions:

- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
- Use arrow functions for simple functions (less than 3 instructions).
- Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO:
  - Use an object to pass multiple parameters.
  - Use an object to return results.
- Declare necessary types for input arguments and output.
- Use a single level of abstraction.

Data:

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
- Use readonly for data that doesn't change.
- Use as const for literals that don't change.

Classes:

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

Exceptions:

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
- Otherwise, use a global handler.

Testing:

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
- Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
- Use test doubles to simulate dependencies.
  - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
- Follow the Given-When-Then convention.

## Specific to Fastify

Basic Principles:

- Use a modular architecture for your Fastify API.
- Encapsulate the API into modules:

  - One module per domain or main route.
  - One route for each HTTP resource, encapsulated in plugins.
  - One handler per route that deals with its business logic.
  - Do proper separation of concerns and DRY Principle especially

- Use hooks (onRequest, preHandler, etc.) for request lifecycle management.
- Validation:
  - Validate input with JSON schemas and ajv for Fastify's built-in validation.
  - Use DTOs or input types for handling structured data.
- Prisma ORM:
  - Use Prisma Client to interact with your database.
  - Create services to manage entities and abstract database operations from the handlers.
  - Use Prisma's schema for generating types and migrations.
- A core folder for shared utilities:
  - Middleware for common request handling.
  - Global error handlers.
  - Logging and instrumentation.
  - Utility functions used across the application.
- Environment management:
  - Use dotenv or a similar library to manage environment variables.
  - Store sensitive information in environment variables (like DB_URL).

Testing:

- Use the Jest framework for unit and integration tests.
- Write unit tests for every service and handler.
- Use test doubles (mocks, stubs) to simulate dependencies.
- Write end-to-end tests using Fastify's inject method for simulating requests.
- Create a /health route for health checks or smoke tests in each module.

-----------------------------

Overview:
This project aims to optimize Liquid Staking Token (LST) yield maximization on the Solana blockchain. Users deposit SOL, and the system dynamically swaps between different LSTs to maximize returns based on real-time APY tracking and profitability analysis.

Dynamic Data Sources:
To ensure scalability and accuracy, all critical data points are fetched dynamically from external APIs and the Solana blockchain:

1. Epoch Duration (Solana Network Timing): Fetched dynamically at the start of each new epoch to avoid hardcoding Used to determine when to check for profitable swaps.

API Request (Solana Epoch Info):

curl -X POST https://api.mainnet-beta.solana.com \
 -H "Content-Type: application/json" \
 -d '{
"jsonrpc": "2.0",
"id": 1,
"method": "getEpochInfo",
"params": []
}'

2. SOL Inflation Rate (Dynamic Calculation): Pulled dynamically from Solana network statistics. Avoids hardcoding inflation assumptions.

API Request (Solana Inflation Rate):

curl -X POST https://api.mainnet-beta.solana.com \
 -H "Content-Type: application/json" \
 -d '{
"jsonrpc": "2.0",
"id": 1,
"method": "getInflationRate",
"params": []
}'

3. LST APY Data (Current and Historical): APY values are retrieved dynamically for all available LSTs. Helps determine whether a swap is profitable.

API Request (Current APY for All LSTs):

curl -X GET "https://extra-api.sanctum.so/v1/apy/latest" -H "accept: application/json"

API Request (Historical APY for a Specific LST):

curl -X GET "https://extra-api.sanctum.so/v1/apy/indiv-epochs?lst={LST_SYMBOL}&n=100" -H "accept: application/json"

4. LST Price Data: Fetches real-time price of all available LSTs in SOL. Used to determine swap profitability and user portfolio value.

API Request (LST Price in SOL):

curl -X GET "https://sanctum-s-api.fly.dev/v1/price?input={LST_MINT_ADDRESS}" -H "accept: application/json"

5. Available LST Listings: Retrieves all LSTs that can be considered for swapping. Ensures coverage of all staking opportunities.

API Request (Fetch All LSTs):

curl -X GET "https://sanctum-s-api.fly.dev/v1/lsts" -H "accept: application/json"

6. Swap Quotes & Execution: Fetches swap quotes from Jupiter and Sanctum APIs. Chooses the most cost-efficient route dynamically.

API Request (Jupiter Swap Quote):

curl -X GET "https://quote-api.jup.ag/v6/quote?inputMint={SOURCE_TOKEN}&outputMint={DEST_TOKEN}&amount={AMOUNT}" -H "accept: application/json"

API Request (Sanctum Swap Quote):

curl -X GET "https://sanctum-s-api.fly.dev/v2/swap/quote?input={SOURCE_TOKEN}&outputLstMint={DEST_TOKEN}&amount={AMOUNT}" -H "accept: application/json"

These dynamic data sources ensure real-time accuracy for all calculations, maximizing profitability, efficiency, and transparency in the system.

Dynamic Swap Logic + Profitability Measures and All Checks:

1. Swap Execution Criteria: A swap is executed only if it increases the user's profit after accounting for:
   a. Swap fees (Jupiter & Sanctum API fees).
   b. Expected APY yield over the current epoch.
   c. Price slippage and volatility risks.

2. Profitability Calculation Formula
   Swap occurs only if:

(Expected LST Yield - Swap Fees) > Holding SOL APY
(Expected LST Yield - Swap Fees) > (Current LST Yield - Swap Fees)

Expected yield is computed using the APY retrieved for each LST.
Formula:
Expected LST Yield = (LST Balance) _ (APY) _ (Epoch Duration / Yearly Duration)
Uses real-time APY fetched from Sanctum API.
Adjusts for dynamic epoch durations (~2-3 days on Solana).

If no swap is profitable, the user’s funds remain in the current LST.

3. Stop-Loss Mechanism: If an LST loses more than 60% of its value, funds are converted back to SOL immediately. Uses real-time price tracking to trigger stop-loss transactions.

4. Dynamic Swap Logic
   a. Swap Execution Flow
   i. Retrieve the current epoch and all available LST APY values.
   ii. Identify the highest APY LST while ensuring swap profitability.
   iii. Fetch swap quotes from Jupiter and Sanctum APIs.
   iv. Choose the cheapest swap route dynamically.
   v. Simulate the transaction before execution.
   vi. If the swap is profitable, execute the transaction.
   vii. Store the transaction hash and update the user’s LST holdings.

   b. Swap Execution Rate:
   i. Swaps are checked every epoch dynamically.
   ii. Batch execution is avoided to ensure each user’s funds are handled independently.


API Endpoints:

1. POST /auth/sign-in: Authenticate user with wallet signature.
2. POST /auth/verify-token: Verify JWT token for session authentication.

3. POST /deposits: User deposits SOL into the system.
4. GET /deposits/{user_id}: Fetch deposit history for a user.
5. POST /withdrawals: User requests withdrawal in SOL or LST.
6. GET /withdrawals/{user_id}: Fetch withdrawal history for a user.

7. GET /users/{user_id}/portfolio
8. GET /users/{user_id}/profit-history
9. GET /transactions/{user_id}

10. GET /holdings/{user_id}

11. GET /lst/available: List all available LSTs.
12. GET /swaps/quote: Fetch best swap quotes from Jupiter & Sanctum APIs.
13. POST /swaps/execute: Perform swap if profitable.
14. GET /swaps/routes: Get available swap routes

15. GET /network-details
16. GET /system/health: Fetch overall system health.
17. GET /logs/errors: Fetch system error logs.

Core Algorithm Objective:
- Per-User Isolation:
    a. Each user's funds are managed independently
    b. User A (1 SOL) and User B (2 SOL) will have separate swap transactions
    c. No pooling of funds to maintain transaction isolation

- Pre-Swap Analysis Flow: 
    a. Current Position Analysis
        i. Check current LST holding value in SOL
        ii. Get current LST's APY from Sanctum API
        iii. Calculate current yield rate
    b. Market Analysis
        i. Fetch all available LSTs (Sanctum API)
        ii. Get real-time APY for each LST (Sanctum API)
        iii. Get current prices for all LSTs (Sanctum API)
        iv. Calculate price stability metrics
        v. Identify top 3 highest APY options
    c. Profitablity Calculations:
            For each potential LST swap:
            Net Profit = (Expected New Yield - Current Yield) - (Swap Fees + Slippage)
            where:
            - Expected New Yield = New LST APY * Amount * (Epoch Duration/365)
            - Current Yield = Current LST APY * Amount * (Epoch Duration/365)
            - Swap Fees = Jupiter/Sanctum fees + Network fees
            - Slippage = Estimated price impact
    d. Risk Assessment
        - Price volatility check (last 24h)
        - Volume check (ensure sufficient liquidity)
        - Smart contract risk check (LST protocol status)
        - Historical APY stability check [Get historical APY Data from Sanctum API]

- Swap Decision Criteria
    1. Primary Checks:
        - New APY must be at least 2% higher than current (configurable threshold)
        - Swap fees must be < 10% of expected yearly yield gain
        - LST must have minimum 7-day price stability
        - LST must have sufficient liquidity for the swap amount
    2. Route Optimization:
        - Get quotes from both Jupiter and Sanctum
        - Compare total fees and slippage
        - Select most cost-effective route
    3. Simulation Checks:
        - Simulate transaction using Jupiter/Sanctum APIs
        - Verify expected output amount
        - Verify slippage within limits
        - Estimate gas costs

- Edge Cases & Safety Measures:
    a. Network Issues:
        - Retry logic for failed API calls
        - Fallback APIs where possible
        - Transaction timeout handling
    b. Market Conditions:
        - Extreme market volatility
        - Liquidity crises
    c. Stop-Loss Triggers:
        - 60% value drop protection
        - Abnormal APY fluctuations
    d. Transaction Safety:
        - Transaction simulation before execution
        - Rollback mechanism for failed swaps

- Execution Flow:
    - Every epoch (or configured interval):
        a. Run analysis for each user independently
        b. Queue profitable swaps
        c. Execute each swap separately
        d. Verify and log results
    - For each swap:
        a. Double-check profitability before execution
        b. Simulate transaction
        c. Execute if simulation successful
        d. Verify output amounts
        e. Update user portfolio

Schemas:
1. users
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    wallet_address TEXT UNIQUE NOT NULL,

    total_deposits_sol DECIMAL(18,9) DEFAULT 0,      
    total_withdrawals_sol DECIMAL(18,9) DEFAULT 0, 
    current_deposit_sol DECIMAL(18,9) DEFAULT 0,

    total_value_sol DECIMAL(18,9) DEFAULT 0,
    unrealized_profit_sol DECIMAL(18,9) DEFAULT 0,
    realized_profit_sol DECIMAL(18,9) DEFAULT 0,
    total_profit_sol DECIMAL(18,9) DEFAULT 0, 

    profit_percentage DECIMAL(6,2) DEFAULT 0,

    holdings,
    status lst_status,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    CONSTRAINT positive_deposits CHECK (total_deposits_sol >= 0),
    CONSTRAINT positive_withdrawals CHECK (total_withdrawals_sol >= 0),
    CONSTRAINT valid_current_deposit CHECK (current_deposit_sol >= 0),
    CONSTRAINT valid_portfolio_value CHECK (total_value_sol >= 0)

2. lst_tokens
    mint_address TEXT PRIMARY KEY,
    symbol TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    image_url TEXT,
    protocol_name TEXT NOT NULL,
    protocol_website TEXT,    
    is_verified BOOLEAN DEFAULT false,

    current_apy DECIMAL(6,2),
    current_price_sol DECIMAL(18,9),
    total_liquidity_sol DECIMAL(18,9),
    market_cap_sol DECIMAL(18,9),

    avg_apy_over_history --value
    avg_apy_over_history JSONB, -- {"epochNumber": "apy"}

    validator_identity TEXT, 
    vote_identity TEXT, 
    activated_stake DECIMAL(18,6),
    commission DECIMAL(4,2), 
    vote_success DECIMAL(5,2),
    skip_rate DECIMAL(5,2), 
    uptime DECIMAL(5,2), 
    wiz_score DECIMAL(5,2),
    stake_ratio DECIMAL(5,2),
    staking_version TEXT

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()

3. user_holdings
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    lst_mint_address TEXT NOT NULL,
    amount DECIMAL(18,9) NOT NULL,
    value_in_sol DECIMAL(18,9) NOT NULL,
    entry_price_sol DECIMAL(18,9) NOT NULL,
    unrealized_profit_sol DECIMAL(18,9) DEFAULT 0,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_lst FOREIGN KEY (lst_mint_address) REFERENCES lst_tokens(mint_address),
    CONSTRAINT unique_user_lst UNIQUE(user_id, lst_mint_address),
    CONSTRAINT positive_amount CHECK (amount >= 0)

3. deposits
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    
    transaction_hash TEXT UNIQUE,
    wallet_address TEXT NOT NULL,
    
    amount_sol DECIMAL(18,9) NOT NULL,
    network_fee_sol DECIMAL(18,9),
    
    status deposit_status DEFAULT 'pending',
    error_message TEXT,
    confirmation_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT positive_amount CHECK (amount_sol > 0)

4. withdrawals
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    
    transaction_hash TEXT UNIQUE,
    wallet_address TEXT NOT NULL,
    
    requested_amount_sol DECIMAL(18,9) NOT NULL,
    actual_amount_sol DECIMAL(18,9),
    network_fee_sol DECIMAL(18,9),
    conversion_fee_sol DECIMAL(18,9),
    
    withdrawal_type withdrawal_type NOT NULL,
    lst_mint_address TEXT,
    lst_amount DECIMAL(18,9),
    conversion_price_sol DECIMAL(18,9),
    
    status withdrawal_status DEFAULT 'pending',
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_lst FOREIGN KEY (lst_mint_address) REFERENCES lst_tokens(mint_address),
    CONSTRAINT positive_amount CHECK (requested_amount_sol > 0)
    CONSTRAINT valid_actual_amount CHECK (actual_amount_sol <= requested_amount_sol),
    CONSTRAINT valid_fees CHECK (network_fee_sol >= 0 AND conversion_fee_sol >= 0),
    CONSTRAINT valid_withdrawal_amount CHECK (requested_amount_sol <= (SELECT total_deposits_sol - total_withdrawals_sol FROM users WHERE users.id = withdrawals.user_id))

    CREATE INDEX idx_withdrawals_user_status ON withdrawals(user_id, status);
    CREATE INDEX idx_withdrawals_hash ON withdrawals(transaction_hash);
    CREATE INDEX idx_withdrawals_created ON withdrawals(created_at);

5. explorer
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    
    transaction_type transaction_type NOT NULL,
    transaction_hash TEXT UNIQUE,
    reference_id UUID NOT NULL, -- Links to deposits/withdrawals/swaps table
    
    amount_sol DECIMAL(18,9) NOT NULL,
    fee_sol DECIMAL(18,9) NOT NULL,
    
    lst_mint_address TEXT,
    lst_amount DECIMAL(18,9),
    lst_price_sol DECIMAL(18,9),
    
    portfolio_value_before_sol DECIMAL(18,9) NOT NULL,
    portfolio_value_after_sol DECIMAL(18,9) NOT NULL,
    profit_impact_sol DECIMAL(18,9),
    
    status transaction_status NOT NULL,
    error_message TEXT,
    confirmation_count INTEGER DEFAULT 0,
    
    block_number BIGINT,
    block_time BIGINT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_lst FOREIGN KEY (lst_mint_address) REFERENCES lst_tokens(mint_address),
    CONSTRAINT valid_amounts CHECK (
        amount_sol >= 0 AND
        fee_sol >= 0 AND
        portfolio_value_before_sol >= 0 AND
        portfolio_value_after_sol >= 0
    )

6. epoch_profits
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    
    start_value_sol DECIMAL(18,9) NOT NULL,
    end_value_sol DECIMAL(18,9) NOT NULL,
    epoch_number
    
    total_profit_sol DECIMAL(18,9) NOT NULL,
    profit_percentage DECIMAL(6,2) NOT NULL,
    
    best_performing_lst TEXT,
    best_lst_apy DECIMAL(6,2),
    worst_performing_lst TEXT,
    worst_lst_apy DECIMAL(6,2),
    
    epoch_start_time TIMESTAMP WITH TIME ZONE NOT NULL,
    epoch_end_time TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at
    
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_best_lst FOREIGN KEY (best_performing_lst) REFERENCES lst_tokens(mint_address),
    CONSTRAINT fk_worst_lst FOREIGN KEY (worst_performing_lst) REFERENCES lst_tokens(mint_address)
    
7. swaps
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    
    transaction_hash TEXT UNIQUE,
    
    source_lst_mint TEXT NOT NULL,
    source_amount DECIMAL(18,9) NOT NULL,
    source_price_sol DECIMAL(18,9) NOT NULL,
    source_apy DECIMAL(6,2) NOT NULL,
    
    destination_lst_mint TEXT NOT NULL,
    destination_amount DECIMAL(18,9),
    destination_price_sol DECIMAL(18,9) NOT NULL,
    destination_apy DECIMAL(6,2) NOT NULL,
    
    route_source swap_route_source NOT NULL,
    route_details JSONB NOT NULL,
    quoted_output_amount DECIMAL(18,9) NOT NULL,
    actual_output_amount DECIMAL(18,9),
    
    network_fee_sol DECIMAL(18,9) NOT NULL,
    protocol_fee_sol DECIMAL(18,9) NOT NULL,
    slippage_bps INTEGER NOT NULL,
    price_impact_percent DECIMAL(6,2) NOT NULL,
    
    expected_profit_sol DECIMAL(18,9) NOT NULL,
    actual_profit_sol DECIMAL(18,9),
    
    status swap_status DEFAULT 'pending',
    error_message TEXT,
    simulation_successful BOOLEAN,
    confirmation_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_source_lst FOREIGN KEY (source_lst_mint) REFERENCES lst_tokens(mint_address),
    CONSTRAINT fk_destination_lst FOREIGN KEY (destination_lst_mint) REFERENCES lst_tokens(mint_address),
    CONSTRAINT different_tokens CHECK (source_lst_mint != destination_lst_mint),
    CONSTRAINT valid_amounts CHECK (
        source_amount > 0 AND
        quoted_output_amount > 0 AND
        network_fee_sol >= 0 AND
        protocol_fee_sol >= 0
    )